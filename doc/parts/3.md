## DB管理

### railsコマンドで利用できるdbタスク

![Railsコマンドで実行できるDBタスク一覧](/public//images/db-tasks.png)

マイグレーションで利用できる専用のメソッドは以下
| | |
| --- | --- |
| up | デーブル情報を反映 |
| down | テーブル情報を巻き戻す |
| change | up, downのそれぞれで呼び出されるメソッド<br>`create_table`が呼び出されている場合は、Railsが読み替えてup時には作成、down時には削除をよしなに行ってくれる。(よしなに読み替えてくれるメソッドは[Railsガイド](https://railsguides.jp/active_record_migrations.html#change%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%82%92%E4%BD%BF%E3%81%86)参照) |

実施したマイグレーションを取り消したい場合は、以下コマンドを実行

```
# 直前をロールバックしたい場合はSTEPオプション不要
$ rails db:rollback STEP=1
== 20240626022103 CreateEntries: reverting ====================================
-- drop_table(:entries)
   -> 0.0155s
== 20240626022103 CreateEntries: reverted (0.0240s) ===========================
```


#### 一度データを削除してから、再度seedファイルを呼び出す方法

`seed`が種なので、replantで再度植えましょう。的な意味合いになる！（ちょっとカッコいい）

```
$ rails db:seed:replant
```

#### DB作成、テーブル作成、seed読み込みまでを一括で行う方法

```
$ rails db:setup
```

#### DBが存在する場合はマイグレーションの更新、存在しない場合はセットアップをよしなに行う方法

```
$ rails db:prepare
```

#### DBの複数化

アプリケーションの規模が大きくなると、応答速度が落ちてきます。
その場合、ボトルネックになっている部分はDBアクセスの部分であった。ということがしばしばあります。

AWSのRDSであれば、レプリカを作成することは容易なので、RDSでのレプリカ作成がいいと思いますが、Rails側で行うのであれば以下の設定で可能です。

**docker環境の場合は、DBのコンテナを別途作成してあげる必要があるので、注意が必要です。**

1. database.ymlにレプリカを作成します(Dockerの場合は、コンテナを別途作成します)

◆特定モデルのみ特定のDBを参照する

```
$ rails g model model column:type --database=[任意のDB名]
```

任意のDBを参照するように書かれた抽象クラスを作成してくれる.
~~~~Ruby
class SubRecord < ApplicationRecord
  self.abstract_class = true

  connects_to database: { writing: :sub }
end

class Author < SubRecord
end
~~~~

◆書き込みと読み込みを分離する

1. dbタスクの読み込みと書き込みを制御方法
  database.ymlにてレプリカDBを指定します。
    ~~~~Ruby
    default: &default
      ...

    development:
      primary:
        <<: *default
        host: primary_db
        database: myapp_development
      sub:
        <<: *default
        host: sub_db
        database: myapp_development_sub
        migrations_paths: db/sub_migrate
        replica: true # こちらで指定
    ~~~~

2. アプリケーション上での読み込みと書き込みを制御方法
  ApplicationRecordクラスで設定し、DRYに書きます。
    ~~~~Ruby
    class ApplicationRecord < ActiveRecord::Base
      self.abstract_class = true

      # 以下を追記
      connects_to database: {
        writing: :primary,
        reading: :sub
      }
    end
    ~~~~

    ロール名(writing, reading)を変更したい場合は、config/application.rbで変更できます
      ~~~~Ruby
      module Myapp
        class Application < Rails::Application
          config.active_record.writing_role = :writable
          config.active_record.reading_role = :readonly
        end
      end  
      ~~~~

    全てのレコードに適用させたい場合は、以下のコード(enviroments/production.rb)に記載があります。
      ~~~~Ruby
      Rails.application.configure do
        config.active_record.database_selector = { delay: 2.seconds }
        config.active_record.database_resolver = ActiveRecord::Middleware::DatabaseSelector::Resolver
        config.active_record.database_resolver_context =  ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
      end
      ~~~~

    上記コードを使用することで、1の`replica: true`を設定するのみでアプリケーション上でも読み取りと書き込みを割り振ることができます。

    | 項目名 | 使いどき |
    | --- | --- |
    | database_selector | DBの基本的な設定を一括で管理したい |
    | connets_to | database_selectorのレールから外れる場合の個別対応 |
